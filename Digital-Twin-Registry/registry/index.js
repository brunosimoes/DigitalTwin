const express = require("express");
const Docker = require("dockerode");
const cors = require("cors");
const { exec } = require("child_process");
const path = require("path");
const fs = require("fs");
const app = express();
const Ajv = require("ajv");
const ajv = new Ajv();
const utils = require("./utils.js");

const port = parseInt(process.env.SERVER_PORT_BINDING) || 3000;
const authMiddleware = utils.authMiddleware;

// Copy default settings if not present
const error = utils.resetRegistrySettings();
if (error) console.error(error);

// Enable CORS for all routes
app.use(cors());

// Middleware to parse JSON bodies
app.use(express.json());

const docker = new Docker();

// List all containers
app.get("/containers", authMiddleware, async (req, res) => {
  try {
    const containers = await docker.listContainers({ all: true });
    console.log(`Container list requested.`);
    res.status(200).json(containers);
  } catch (error) {
    res.status(500).send(`Error listing containers: ${error.message}`);
  }
});

// Start a container
app.get("/start-container/:id", authMiddleware, async (req, res) => {
  const containerId = req.params.id;
  try {
    const container = docker.getContainer(containerId);
    await container.start();
    console.log(`Container ${containerId} started successfully.`);
    res.status(200).send(`Container ${containerId} started successfully.`);
  } catch (error) {
    res.status(500).send(`Error starting container ${containerId}: ${error.message}`);
  }
});

// Stop a container
app.get("/stop-container/:id", authMiddleware, async (req, res) => {
  const containerId = req.params.id;

  try {
    const container = docker.getContainer(containerId);
    await container.stop();
    console.log(`Container ${containerId} stopped successfully.`);
    res.status(200).send(`Container ${containerId} stopped successfully.`);
  } catch (error) {
    res.status(500).send(`Error stopping container ${containerId}: ${error.message}`);
  }
});

// Restart a container
app.get("/restart-container/:id", authMiddleware, async (req, res) => {
  const containerId = req.params.id;
  try {
    const container = docker.getContainer(containerId);
    await container.restart();
    console.log(`Container ${containerId} restarted successfully.`);
    res.status(200).send(`Container ${containerId} restarted successfully.`);
  } catch (error) {
    res.status(500).send(`Error restarting container ${containerId}: ${error.message}`);
  }
});

app.post("/validate", authMiddleware, (req, res) => {
  const data = req.body;
  const validTypes = ["digitaltwin", "microfrontend", "microservice", "hybrid", "otherservice"];

  if (!data.type || !validTypes.includes(data.type)) {
    return res
      .status(200)
      .json({ type: data.type, errors: [{ message: "type is missing or has an invalid value" }] });
  }

  try {
    // Delete autogenerated properties
    if (data.type === "microfrontend") {
      data.endpoint = "autogenerated";
      data.url = "autogenerated";
      data.remote = "autogenerated";
      data.version = "1";
    } else {
      delete data.devServerHost;
      delete data.devRegistryURL;
    }
    delete data.schema;

    const schema = require(`./data/schema/${data.type}.json`);
    const validate = ajv.compile(schema);
    const valid = validate(data);

    if (valid) {
      return res.status(200).json({ type: data.type, message: "JSON is valid against the schema" });
    } else {
      console.log(validate);
      return res.status(200).json({ type: data.type, errors: validate.errors });
    }
  } catch (err) {
    console.error("Error during validation:", err);
    if (err.code === "MODULE_NOT_FOUND") {
      return res.status(500).json({ type: data.type, message: "Schema file not found" });
    }
    return res.status(500).json({ type: data.type, message: "Internal server error" });
  }
});

// In case you use a docker volume for the settings, you will have to call this endpoint
// before you recompile the module to set new values
app.get("/reset-config", authMiddleware, async (req, res) => {
  const error = utils.resetRegistrySettings(true);
  if (error) res.status(500).json({ error: "Error resetting config." });
  else res.status(200).json({ message: "Config reset successfully." });
});

app.get("/config", authMiddleware, (_req, res) => {
  try {
    // Read the JSON files
    const basePath = path.join(__dirname, "config");
    const config = JSON.parse(fs.readFileSync(path.join(basePath, "config.json"), "utf8"));
    const modules = JSON.parse(fs.readFileSync(path.join(basePath, "modules.json"), "utf8"));

    // Combine the data into a single JSON object
    const jsonData = {
      config: config,
      modules: modules,
    };

    // Send the combined JSON response
    res.json(jsonData);
  } catch (error) {
    // Handle errors
    console.error("Error reading JSON files:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.post("/config", authMiddleware, (req, res) => {
  if (isAdminConsoleEnabled()) {
    const data = req.body;
    fs.writeFileSync(path.join(basePath, "config.json"), data);
  } else {
    return res.status(500).json({ error: "Control feature is disabled." });
  }
});

app.post("/modules", authMiddleware, (req, res) => {
  if (isAdminConsoleEnabled()) {
    const data = req.body;
    fs.writeFileSync(path.join(basePath, "modules.json"), data);
  } else {
    return res.status(500).json({ error: "Control feature is disabled." });
  }
});

app.post("/echo", authMiddleware, (req, res) => {
  console.log(req.body);
  res.status(200).json({ error: "Updated" });
});

app.post("/orchestrator", authMiddleware, (req, res) => {
  if (isAdminConsoleEnabled()) {
    const option = req.body.option;
    if (!option) {
      return res.status(400).json({ error: "Feature is missing in the request body." });
    }
    let commandOption;
    switch (option) {
      case "configure":
        commandOption = 7;
        break;
      case "clear":
        commandOption = 8;
        break;
      case "run":
        commandOption = 4;
        break;
      case "restart":
        commandOption = 9;
        break;
      case "push":
        commandOption = 6;
        break;
      case "build":
        commandOption = 6;
        break;
      case "pull":
        commandOption = 5;
        break;
      case "createPBC":
        commandOption = 10;
        break;
      default:
        return res.status(400).json({ error: "Invalid option provided." });
    }
    const command = `cd .. && ls && echo "${commandOption ?? 13}" | ./orchestrator.sh`;
    exec(command, (error, stdout, stderr) => {
      if (error) {
        console.error("Error:", error);
        return res.status(500).json({ error: "An error occurred while executing the operation." });
      }
      const output = stdout || stderr;
      res.send(`${output.replace("\n", "<br>")}`);
    });
  } else {
    return res.status(500).json({ error: "Control feature is disabled." });
  }
});

app.get("/editable", authMiddleware, (_req, res) => {
  const value = { editable: false };
  try {
    const capsDir = "/srv/Digital-Twin-Capabilities";
    const capabilities = fs.existsSync(capsDir) && fs.statSync(capsDir).isDirectory();
    const appsDir = "/srv/Digital-Twin-Apps";
    const apps = fs.existsSync(appsDir) && fs.statSync(appsDir).isDirectory();
    value.editable = apps && capabilities;
  } catch (err) {
    console.log(err);
  }
  res.status(200).send(value);
});

app.get("/templates", authMiddleware, (_req, res) => {
  const templates = [];
  try {
    // Step 1: Read folders inside Plugins
    const pluginsPath = "/srv/Digital-Twin-Plugins";
    const pluginFolders = fs
      .readdirSync(pluginsPath, { withFileTypes: true })
      .filter((dirent) => dirent.isDirectory())
      .map((dirent) => dirent.name);

    // Step 2 & 3: For each folder, read module.json and add template to templates
    pluginFolders.forEach((folder) => {
      const moduleJsonPath = path.join(pluginsPath, folder, "config", "module.json");
      if (fs.existsSync(moduleJsonPath)) {
        const moduleJson = require(moduleJsonPath);
        if (moduleJson.label) {
          templates.push({ label: moduleJson.label, folder: folder });
        }
      }
    });
  } catch (err) {
    console.log(err);
  }
  res.status(200).send(templates);
});

app.get("/version", authMiddleware, (_req, res) => {
  res.status(200).send({ version: 1 });
});

app.get("/", authMiddleware, (req, res) => {
  res.sendFile(path.join(__dirname, "public/index.html"));
});

app.use(express.static("public"));

app.listen(port, () => {
  console.log(`Docker API listening at http://localhost:${port}`);
});
